{"ast":null,"code":"import * as i0 from \"@angular/core\";\nconst STORAGE_KEY = 'apwu_scheduler_meetings_v1';\nexport class SchedulerService {\n  listAll() {\n    return loadMeetings().sort((a, b) => a.start.localeCompare(b.start));\n  }\n  listForUser(email) {\n    return this.listAll().filter(m => m.participants.includes(email) || m.createdBy === email);\n  }\n  upcomingForUser(email, limit = 8) {\n    const now = new Date().toISOString();\n    return this.listForUser(email).filter(m => m.status === 'scheduled' && m.start >= now).sort((a, b) => a.start.localeCompare(b.start)).slice(0, limit);\n  }\n  create(payload) {\n    const meetings = loadMeetings();\n    if (!payload.title?.trim()) return {\n      ok: false,\n      error: 'Title is required.'\n    };\n    if (!payload.start || !payload.end) return {\n      ok: false,\n      error: 'Start and end are required.'\n    };\n    if (new Date(payload.end) <= new Date(payload.start)) return {\n      ok: false,\n      error: 'End must be after start.'\n    };\n    if (!payload.participants?.length) return {\n      ok: false,\n      error: 'Select at least one participant.'\n    };\n    const conflicting = meetings.find(m => m.status === 'scheduled' && overlaps(payload.start, payload.end, m.start, m.end) && m.participants.some(p => payload.participants.includes(p)));\n    if (conflicting) return {\n      ok: false,\n      error: 'Time conflict with another meeting for a participant.'\n    };\n    const now = new Date().toISOString();\n    const meeting = {\n      ...payload,\n      id: crypto.randomUUID(),\n      status: 'scheduled',\n      createdAt: now,\n      updatedAt: now\n    };\n    meetings.push(meeting);\n    saveMeetings(meetings);\n    return {\n      ok: true,\n      meeting\n    };\n  }\n  update(id, patch) {\n    const meetings = loadMeetings();\n    const idx = meetings.findIndex(m => m.id === id);\n    if (idx < 0) return {\n      ok: false,\n      error: 'Meeting not found.'\n    };\n    const updated = {\n      ...meetings[idx],\n      ...patch,\n      updatedAt: new Date().toISOString()\n    };\n    if (new Date(updated.end) <= new Date(updated.start)) return {\n      ok: false,\n      error: 'End must be after start.'\n    };\n    const timeChanged = patch.start || patch.end || patch.participants;\n    if (timeChanged) {\n      const conflict = meetings.find(m => m.id !== id && m.status === 'scheduled' && overlaps(updated.start, updated.end, m.start, m.end) && m.participants.some(p => updated.participants.includes(p)));\n      if (conflict) return {\n        ok: false,\n        error: 'Time conflict with another meeting.'\n      };\n    }\n    meetings[idx] = updated;\n    saveMeetings(meetings);\n    return {\n      ok: true,\n      meeting: updated\n    };\n  }\n  cancel(id) {\n    const meetings = loadMeetings();\n    const idx = meetings.findIndex(m => m.id === id);\n    if (idx < 0) return {\n      ok: false,\n      error: 'Meeting not found.'\n    };\n    meetings[idx].status = 'cancelled';\n    meetings[idx].updatedAt = new Date().toISOString();\n    saveMeetings(meetings);\n    return {\n      ok: true\n    };\n  }\n  static {\n    this.ɵfac = function SchedulerService_Factory(t) {\n      return new (t || SchedulerService)();\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: SchedulerService,\n      factory: SchedulerService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n/* helpers */\nfunction loadMeetings() {\n  try {\n    const raw = localStorage.getItem(STORAGE_KEY);\n    return raw ? JSON.parse(raw) : [];\n  } catch {\n    return [];\n  }\n}\nfunction saveMeetings(list) {\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(list));\n}\nfunction overlaps(aStart, aEnd, bStart, bEnd) {\n  return new Date(aStart) < new Date(bEnd) && new Date(bStart) < new Date(aEnd);\n}","map":{"version":3,"names":["STORAGE_KEY","SchedulerService","listAll","loadMeetings","sort","a","b","start","localeCompare","listForUser","email","filter","m","participants","includes","createdBy","upcomingForUser","limit","now","Date","toISOString","status","slice","create","payload","meetings","title","trim","ok","error","end","length","conflicting","find","overlaps","some","p","meeting","id","crypto","randomUUID","createdAt","updatedAt","push","saveMeetings","update","patch","idx","findIndex","updated","timeChanged","conflict","cancel","factory","ɵfac","providedIn","raw","localStorage","getItem","JSON","parse","list","setItem","stringify","aStart","aEnd","bStart","bEnd"],"sources":["/Users/zaq/Documents/GitHub/Angular-APWU/src/app/features/scheduler/services/scheduler.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Meeting } from '../models/meeting.model';\n\nconst STORAGE_KEY = 'apwu_scheduler_meetings_v1';\n\n@Injectable({ providedIn: 'root' })\nexport class SchedulerService {\n\n  listAll(): Meeting[] {\n    return loadMeetings().sort((a, b) => a.start.localeCompare(b.start));\n  }\n\n  listForUser(email: string): Meeting[] {\n    return this.listAll().filter(m => m.participants.includes(email) || m.createdBy === email);\n  }\n\n  upcomingForUser(email: string, limit = 8): Meeting[] {\n    const now = new Date().toISOString();\n    return this\n      .listForUser(email)\n      .filter(m => m.status === 'scheduled' && m.start >= now)\n      .sort((a, b) => a.start.localeCompare(b.start))\n      .slice(0, limit);\n  }\n\n  create(payload: Omit<Meeting, 'id' | 'status' | 'createdAt' | 'updatedAt'>): { ok: boolean; error?: string; meeting?: Meeting } {\n    const meetings = loadMeetings();\n\n    if (!payload.title?.trim()) return { ok: false, error: 'Title is required.' };\n    if (!payload.start || !payload.end) return { ok: false, error: 'Start and end are required.' };\n    if (new Date(payload.end) <= new Date(payload.start)) return { ok: false, error: 'End must be after start.' };\n    if (!payload.participants?.length) return { ok: false, error: 'Select at least one participant.' };\n\n    const conflicting = meetings.find(m =>\n      m.status === 'scheduled' &&\n      overlaps(payload.start, payload.end, m.start, m.end) &&\n      m.participants.some(p => payload.participants.includes(p))\n    );\n    if (conflicting) return { ok: false, error: 'Time conflict with another meeting for a participant.' };\n\n    const now = new Date().toISOString();\n    const meeting: Meeting = {\n      ...payload,\n      id: crypto.randomUUID(),\n      status: 'scheduled',\n      createdAt: now,\n      updatedAt: now,\n    };\n    meetings.push(meeting);\n    saveMeetings(meetings);\n    return { ok: true, meeting };\n  }\n\n  update(id: string, patch: Partial<Meeting>): { ok: boolean; error?: string; meeting?: Meeting } {\n    const meetings = loadMeetings();\n    const idx = meetings.findIndex(m => m.id === id);\n    if (idx < 0) return { ok: false, error: 'Meeting not found.' };\n\n    const updated: Meeting = { ...meetings[idx], ...patch, updatedAt: new Date().toISOString() };\n    if (new Date(updated.end) <= new Date(updated.start)) return { ok: false, error: 'End must be after start.' };\n\n    const timeChanged = patch.start || patch.end || patch.participants;\n    if (timeChanged) {\n      const conflict = meetings.find(m =>\n        m.id !== id &&\n        m.status === 'scheduled' &&\n        overlaps(updated.start, updated.end, m.start, m.end) &&\n        m.participants.some(p => updated.participants.includes(p))\n      );\n      if (conflict) return { ok: false, error: 'Time conflict with another meeting.' };\n    }\n\n    meetings[idx] = updated;\n    saveMeetings(meetings);\n    return { ok: true, meeting: updated };\n  }\n\n  cancel(id: string): { ok: boolean; error?: string } {\n    const meetings = loadMeetings();\n    const idx = meetings.findIndex(m => m.id === id);\n    if (idx < 0) return { ok: false, error: 'Meeting not found.' };\n    meetings[idx].status = 'cancelled';\n    meetings[idx].updatedAt = new Date().toISOString();\n    saveMeetings(meetings);\n    return { ok: true };\n  }\n}\n\n/* helpers */\nfunction loadMeetings(): Meeting[] {\n  try {\n    const raw = localStorage.getItem(STORAGE_KEY);\n    return raw ? (JSON.parse(raw) as Meeting[]) : [];\n  } catch {\n    return [];\n  }\n}\nfunction saveMeetings(list: Meeting[]) {\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(list));\n}\nfunction overlaps(aStart: string, aEnd: string, bStart: string, bEnd: string): boolean {\n  return new Date(aStart) < new Date(bEnd) && new Date(bStart) < new Date(aEnd);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}